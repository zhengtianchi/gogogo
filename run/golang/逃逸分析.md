# 逃逸分析



## 前言

我们都知道go语言中内存管理工作都是由Go在底层完成的，这样我们可以不用过多的关注底层的内存问题，有更多的精力去关注业务逻辑， 但掌握内存的管理，理解内存分配机制，可以让你写出更高效的代码



## 什么是内存逃逸

在了解什么是内存逃逸之前，我们先来了解两个概念，栈内存和堆内存。

- 堆内存(Heap)：一般来讲是人为手动进行管理，手动申请、分配、释放。一般硬件内存有多大堆内存就有多大。适合不可预知大小的内存分配，分配速度较慢，而且会形成内存碎片。
- 栈内存(Stack):是一种拥有特殊规则的线性表数据结构。由编译器进行管理，自动申请、分配、释放。大小一般是固定的。栈只允许从线性表的同一端放入和取出数据，按照后进先出（LIFO，Last InFirst Out）的顺序

<img src="img/image-20221222210734038.png" alt="image-20221222210734038" style="zoom: 25%;" />

通过上面我们可以看出堆分配昂贵，栈分配廉价，在go中所有内存优先栈分配，那么，Go 编译器怎么知道某个变量需要分配在栈上，还是堆上呢？

- **逃逸分析是用于堆和栈分配进行选择**，通过在编译时期做gc，编译器追踪变量在代码块的作用域，判断变量在整个运行周期是否在运行时完全可知，通过校验可以在栈上分配；否则逃逸到堆上；

- 逃逸分析由编译器完成，作用于编译阶段。



## **逃逸分析基本原则**

编译器会根据变量是否被外部引用来决定是否逃逸：

1. 如果函数外部没有引用，则优先放到栈中；
2. 如果函数外部存在引用，则必定放到堆中;
3. 如果栈上放不开，则必定放到堆上;



## 内存逃逸分析的意义

逃逸分析的好处应该是减少了 gc 的压力，栈的分配比堆快，性能好，如果变量都分配到栈上，可以避免 Go 频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销。



## 逃逸类型

### **指针逃逸**

我们知道Go可以返回局部变量指针，这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。

```javascript
package main

type Person struct {
 Name string
 Age  int
}

func PersonRegister(name string, age int) *Person {
 p := new(Person) //局部变量s逃逸到堆

 p.Name = name
 p.Age = age

 return p
}

func main() {
 PersonRegister("微客鸟窝", 18)
}
```

函数 PersonRegister() 内部 p 为局部变量，其值通过函数返回值返回， p 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。

通过编译参数`-gcflag=-m`可以查看编译过程中的逃逸分析：

```javascript
$ go build -gcflags=-m
# ceshi
.\main.go:8:6: can inline PersonRegister
.\main.go:17:6: can inline main
.\main.go:18:16: inlining call to PersonRegister
.\main.go:8:21: leaking param: name
.\main.go:9:10: new(Person) escapes to heap
.\main.go:18:16: new(Person) does not escape
```

代码第9行显示”escapes to heap”，表示该行内存分配发生了逃逸现象。

### **栈空间不足逃逸**

```javascript
package main

func Slice() {
 s := make([]int, 1000, 1000)

 for index, _ := range s {
  s[index] = index
 }
}

func main() {
 Slice()
}
```

上面代码 Slice() 函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。直接查看编译提示，如下：

```javascript
$ go build -gcflags=-m
# ceshi
.\main.go:11:6: can inline main
.\main.go:4:11: make([]int, 1000, 1000) does not escape
```

发现并没有发生逃逸。我们把切片长度扩大10倍再试试： `s := make([]int, 10000, 10000)`

```javascript
$ go build -gcflags=-m
# ceshi
.\main.go:11:6: can inline main
.\main.go:4:11: make([]int, 10000, 10000) escapes to heap
```

发现当切片长度扩大到10000时就会逃逸。当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。

### **动态类型逃逸**

在 Go 中，空接口 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。

```javascript
package main
import "fmt"

func main() {
 s := "wekenw"
 fmt.Println(s)
}
```

因为 fmt.Println() 的参数类型定义为 interface{}，因此也发生了逃逸。

```javascript
$ go build -gcflags=-m
# ceshi
.\main.go:6:13: inlining call to fmt.Println
.\main.go:6:13: s escapes to heap
.\main.go:6:13: []interface {}{...} does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
```

### **闭包引用对象逃逸**

回Fibonacci数列的函数：

```javascript
package main

func main() {
 f := fibonacci()
 for i := 0; i < 10; i++ {
  f()
 }
}
func fibonacci() func() int {
 a, b := 0, 1
 return func() int {
  a, b = b, a+b
  return a
 }
}
```

Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸：

```javascript
$ go build -gcflags=-m
# ceshi
.\main.go:11:9: can inline fibonacci.func1
.\main.go:10:2: moved to heap: a
.\main.go:10:5: moved to heap: b
.\main.go:11:9: func literal escapes to heap
```



## 怎么避免内存逃逸

1. 尽量减少外部指针引用，必要的时候可以使用值传递；
2. 对于自己定义的数据大小，有一个基本的预判，尽量不要出现栈空间溢出的情况；
3. Golang中的接口类型的方法调用是动态调度，如果对于性能要求比较高且访问频次比较高的函数调用，应该尽量避免使用接口类型；
4. 尽量不要写闭包函数，可读性差且发生逃逸。



## **总结**

- 栈上分配内存比在堆中分配内存效率更高
- 栈上分配的内存不需要 GC 处理，而堆需要
- 逃逸分析目的是决定内分配地址是栈还是堆
- 逃逸分析在编译阶段完成
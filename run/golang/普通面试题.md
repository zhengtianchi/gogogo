# 普通面试题



## 1. 什么是协程（Goroutine）

协程是**用户态轻量级线程**，它是**线程调度的基本单位**。通常在函数前加上go关键字就能实现并发。一个Goroutine会以一个很小的栈启动2KB或4KB，当遇到栈空间不足时，栈会**自动伸缩**， 因此可以轻易实现成千上万个goroutine同时启动。



## 2. 2 个 interface 可以比较吗 ？

Go 语言中，interface 的内部实现包含了 2 个字段，`类型 T 和 值 V`，interface 可以使用 == 或 != 比较。2 个 interface 相等有以下 2 种情况

- 两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）

- 类型 T 相同，且对应的值 V 相等。

看下面的例子：

```go
type Stu struct {

Name string

}



type StuInt interface{}



func main() {

	var stu1, stu2 StuInt = &Stu{"Tom"}, &Stu{"Tom"}

	var stu3, stu4 StuInt = Stu{"Tom"}, Stu{"Tom"}

	fmt.Println(stu1 == stu2) // false

	fmt.Println(stu3 == stu4) // true

}
```

stu1 和 stu2 对应的类型是 *Stu，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。

stu3 和 stu4 对应的类型是 Stu，值是 Stu 结构体，且各字段相等，因此结果为 true。



## 3. goroutine 里面 panic 了会怎么样

在Go语言中，我们通常会用到panic和recover来抛出错误和捕获错误，这一对操作在单协程环境下我们正常用就好了，并不会踩到什么坑。但是在多协程并发环境下，我们常常会碰到以下两个问题。假设我们现在有2个协程，我们叫它们协程A和B好了：

- 如果协程A发生了panic，协程B是否会因为协程A的panic而挂掉？
- 如果协程A发生了panic，协程B是否能用recover捕获到协程A的panic？

答案分别是：会、不能。

==总结==  在一个 gorouting 里 panic ，就要在其 gorouting recover ， 否则整个进程都崩了



## 4. go里面goroutine创建数量有限制吗？





## 5. 值类型和引用类型的区别？

1. 值类型在内存中存储的是值本身，而引用类型在内存中存储的是值的内存地址。
2. 值类型内存通常在栈中分配，引用类型内存通常在堆中分配。



## 6. go 调度时机

在四种情形下，goroutine 可能会发生调度，但也并不一定会发生，只是说 Go scheduler 有机会进行调度。

| 情形            | 说明                                                         |
| :-------------- | :----------------------------------------------------------- |
| 使用关键字 `go` | go 创建一个新的 goroutine，Go scheduler 会考虑调度           |
| GC              | 由于进行 GC 的 goroutine 也需要在 M 上运行，因此肯定会发生调度。当然，Go scheduler 还会做很多其他的调度，例如调度不涉及堆访问的 goroutine 来运行。GC 不管栈上的内存，只会回收堆上的内存 |
| 系统调用        | 当 goroutine 进行系统调用时，会阻塞 M，所以它会被调度走，同时一个新的 goroutine 会被调度上来 |
| 内存同步访问    | atomic，mutex，channel 操作等会使 goroutine 阻塞，因此会被调度走。等条件满足后（例如其他 goroutine 解锁了）还会被调度上来继续运行 |



## 7 Go 中哪些动作会触发 runtime 调度？

**第一种：系统调用 SysCall**

**当你在 goroutine 进行一些 sleep 休眠、读取磁盘或者发送网络请求时，其实都会发生系统调用，进入操作系统内核。**

而一旦发生系统调用，就会直接触发 runtime 的调度，当前的 P 就会去找其他的 M 进行绑定，并取出 G 开始运行。

**第二种：等待锁、通道 （阻塞）**

此外，在你的代码中，**若因为锁或者通道导致代码阻塞了，也会触发调度**。

**第三种：人工触发**

在代码中直接调用 **runtime.Gosched** 方法，也可以手动触发。

**第四种：队列轮询**

不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下文保存下来，然后将G放到队列尾部，然后从队列中重新取出一个G进行调度。





## 8 golang GC 回收介绍 (标记清除, 三色标记法, 混合写屏障)



## 9 什么时候会触发 golang GC 呢



## 10 golang 如何做超时控制 ? (time.After 和 context.WithTimeOut)



## 11 golang 如何 比较两个 map 使用相等



## 12 协程切换的时机？ (网易面试题)

`切换时机`

- 会阻塞的系统调用，比如文件io，网络io；
- time系列定时操作；
- go func的时候, func执行完的时候；
- 管道读写阻塞的情况；
- 垃圾回收之后。
- 主动调用runtime.Gosched()



## 13 channel的底层结构？接收、发送消息的过程？(网易面试题)



## 14 sync. WaitGroup的底层是怎么样实现的 





## 15 golang context 使用场景





## 16 两个结构体可以比较吗



## 17 gmp 为什么要有 p

加了 P 之后会带来什么改变呢？我们再更显式的讲一下。

- **每个 P 有自己的本地队列**，大幅度的减轻了对**全局队列**的直接依赖，**所带来的效果就是锁竞争的减少**。而 GM 模型的性能开销大头就是锁竞争。

- **每个 P 相对的平衡上**，在 GMP 模型中也实现了 **Work Stealing 算法**，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，**减少空转，提高了资源利用率**。

- ### 为什么要有 P

  这时候就有小伙伴会疑惑了，如果是想实现本地队列、Work Stealing 算法，那为什么不直接在 M 上加呢，M 也照样可以实现类似的组件。为什么又再加多一个 P 组件？

  结合 M（系统线程） 的定位来看，若这么做，有以下问题：

  - 一般来讲，M 的数量都会多于 P。**像在 Go 中，M 的数量默认是 10000，P 的默认数量的 CPU 核数**。另外由于 M 的属性，也就是如果存在系统阻塞调用，阻塞了 M，又不够用的情况下，M 会不断增加。
  - M 不断增加的话，如果本地队列挂载在 M 上，那就意味着本地队列也会随之增加。这显然是不合理的，**因为本地队列的管理会变得复杂**，且 Work Stealing 性能会大幅度下降。
  - M 被系统调用阻塞后，我们是期望把他既有未执行的任务分配给其他继续运行的，而不是一阻塞就导致全部停止。

  因此使用 M 是不合理的，那么引入新的组件 P，把本地队列关联到 P 上，就能很好的解决这个问题。



## 18 new 和 make 区别

本质上在于 `make` 函数在初始化时，会初始化 `slice`、`chan`、`map` 类型的内部数据结构，`new` 函数并不会。

例如：在 `map` 类型中，合理的长度（len）和容量（cap）可以提高效率和减少开销。

更进一步的区别：

- ```
  make
  ```

  - 能够创建类型所需的内存空间，返回引用类型的本身。
  - 具有使用范围的局限性，仅支持 `channel`、`map`、`slice` 三种类型。
  - 具有独特的优势，`make` 函数会对三种类型的内部数据结构（长度、容量等）赋值。

- ```
  new
  ```

  - 能够创建并分配类型所需的内存空间，返回指针引用（指向内存的指针）。
  - 可被替代，能够通过字面值快速初始化。



总结下区别，回答时可以说：

- make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；
- new 分配返回的是`指针`，即类型 *Type。make 返回`引用`，即 Type；
- new 分配的空间被清零。make 分配空间后，会进行初始化；



## 19 两个 interface 可以比较吗？

空接口在保存不同的值后，可以和其他变量值一样使用`==`进行比较操作。空接口的比较有以下几种特性。

interface 的内部实现包含了 2 个字段，类型 `T` 和 值 `V`

#### 1) 类型不同的空接口间的比较结果不相同

保存有类型不同的值的空接口进行比较时，Go语言会优先比较值的类型。因此类型不同，比较结果也是不相同的，代码如下：

```go
// a保存整型
var a interface{} = 100

// b保存字符串
var b interface{} = "hi"

// 两个空接口不相等
fmt.Println(a == b)
```

代码输出如下：

false

#### 2) 不能比较空接口中的动态值

当接口中保存有动态类型的值时，运行时将触发错误，代码如下：

```go
// c保存包含10的整型切片
var c interface{} = []int{10}

// d保存包含20的整型切片
var d interface{} = []int{20}

// 这里会发生崩溃
fmt.Println(c == d)
```

代码运行到第8行时发生崩溃：

panic: runtime error: comparing uncomparable type []int

这是一个运行时错误，提示 []int 是不可比较的类型。下表中列举出了类型及比较的几种情况。

| 类  型          | 说  明                                                       |
| --------------- | ------------------------------------------------------------ |
| map             | 宕机错误，不可比较                                           |
| 切片（[]T）     | 宕机错误，不可比较                                           |
| 通道（channel） | 可比较，必须由同一个 make 生成，也就是同一个通道才会是 true，否则为 false |
| 数组（[容量]T） | 可比较，编译期知道两个数组是否一致                           |
| 结构体          | 可比较，可以逐个比较结构体的值                               |
| 函数            | 可比较                                                       |



## 20 Go 的默认栈大小是多少？最大值多少？

 2KB

**为啥会有栈空间扩容**

由于当前的 **Go 的栈结构使用的是连续栈**，并且初始值才 2k 比较小，因此随着函数的调用层级加深，Go 的初始栈空间就可能不够用，不够用的话，就会触发栈空间的扩容。

**栈空间扩容啥时会触发 ** （由 runtime 管理） 

编译器会为函数调用插入运行时检查`runtime.morestack`，它会在几乎所有的函数调用之前检查当前`goroutine` 的栈内存是否充足，如果当前栈需要扩容，会调用`runtime.newstack` 创建新的栈。

而新的栈空间，是旧栈空间大小（通过保存在`goroutine`中的`stack`信息里记录的栈区内存边界计算出来的）的两倍，但最大栈空间大小不能超过 `maxstacksize` ，也就是 **1G。**

**不管是扩容还是缩容，都是使用 `runtime.copystack` 函数来开辟新的栈空间，然后将旧栈的数据全部拷贝至新的栈空间，并调整原来指针的指向。**



## 21 数组和silice 区别

### 数组

- Go语言中的Array即为数据的一种集合，需要在声明时指定容量和初值，且一旦声明就**长度固定**了，访问时按照索引进行访问。通过内置函数`len`可以获取数组中的元素个数。
- `数组在初始化时必须指定大小和初值`，不过Go语言为我们提供了一些更为灵活的方式进行初始化。例如：使用`...`来自动获取长度；未指定值时，用0赋予初值；指定指定元素的初值等。
- Go语言数组作为函数参数时，`必须指定参数数组的大小`，且传入的数组大小必须与指定的大小一致，`数组为**按值传递**的，函数内对数组的值的改变不影响初始数组`

- `golang`中的数组是**`值类型`**,也就是说，如果你将一个数组赋值给另外一个数组，那么，实际上就是整个数组拷贝了一份
- 如果`golang`中的数组作为函数的参数，那么实际传递的参数是一份`数组的拷贝`，而不是数组的指针
- `array`的长度也是`Type`的一部分，这样就说明`[10]int`和`[20]int`是不一样的。

### slice

切片是Go语言中极为重要的一种数据类型，可以理解为**动态长度**的数组（虽然实际上Slice结构内包含了一个数组），访问时可以按照数组的方式访问，也可以通过`切片`操作访问。`Slice有三个属性：指针、长度和容量`。指针即Slice名，指向的为数组中第一个可以由Slice访问的元素；长度指当前slice中的元素个数，不能超过slice的容量；容量为slice能包含的最大元素数量，但实际上当容量不足时，会自动扩充为原来的两倍。通过内置函数`len`和`cap`可以获取slice的长度和容量。

- Go语言Slice作为函数参数传递时为**按引用传递**的 (传递的是指针)，函数内对slice内元素的修改将导致函数外的值也发生改变，不过由于传入函数的是一个指针的副本，所以对该指针的修改不会导致原来的指针的变化（例如append函数不会改变原来的slice的值）



## 22 for range 的时候地址会发生变化吗？

在 for a,b := range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和  b，a，b 的内存地址始终不变。由于有这个特性，「for 循环里面如果开协程，不要直接把 a 或者 b  的地址传给协程」。解决办法：在每次循环时，创建一个临时变量。



## 23 for range 的一些坑

`k,v`地址保持不变，  **range每次都会把当前值赋值到循环变量上，而不是直接使用原变量**

```go
type student struct {
	name string
	age  int
}
func main() {
	m := make(map[string]*student)
	stus := []student{
		{name: "小王子", age: 18},
		{name: "娜扎", age: 23},
		{name: "大王八", age: 9000},
	}
	for _, stu := range stus {
	//每次取的地址都是循环变量的地址（唯一）
		m[stu.name]=&stu
	}
	for k, v := range m {
		fmt.Println(k, "=>", v.name)
	}
}

小王子--》大王八
娜扎--》大王八
大王八--》大王八

迭代变量是被重用的
```





## 24 对 map 遍历时删除元素能遍历到吗？



## 25 对 map 遍历时新增元素能遍历到吗？



## 26 defer 在什么时候会修改返回值？



## 27 golang 中解析 tag 



## 28 反射原理？



## 29 slice 遇到过哪些坑

### 把 slice 传入参数

因为golang总是传值, slice在传入helper函数后, helper函数中的s变量是一个新的变量, append操作修改的是此局部变量的Len值. 而main函数中的s变量, 其Len值始终没有改变.

**切片传值操作**，append未触发扩容，会同时修改底层数组的值，`但不会影响原切片的长度和容量`；当触发扩容，那么会产生副本，后面的修改则会和原底层数组剥离开，互不影响。

如果期望在修改切片后，对原切片也发生修改，则可以使用**传址操作**，始终基于同一个切片变量进行操作。

（详细的可以在 slice 中看）



## 30 go 闭包



## 31 context 使用场景

### 值传递

值传递只是context的一个辅助功能，并不是核心功能。一般我们只用context来传递不影响业务主逻辑的可选数据，比如日志信息、调试信息以及元信息等等。

```go
package main

import (
	"context"
	"fmt"
)

func readContext(ctx context.Context) {
	traceId, ok := ctx.Value("key").(string)
	if ok {
		fmt.Println("readContext key=", traceId)
	} else {
		fmt.Println("readContext no key")
	}
}

func main() {
	ctx := context.Background()
	readContext(ctx)
	ctx = context.WithValue(ctx, "key", "beautiful")
	readContext(ctx)
}

复制代码
```

在使用WithValue对ctx包装时，可以设置一个key-value键值对，在goroutine之间传递。



### 超时控制

**http请求设置超时时间**

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func httpRequest(ctx context.Context) {
	for {
		// 处理http请求
		select {
		case <- ctx.Done():
			fmt.Println("Request timed out")
			return
		case <- time.After(time.Second):
			fmt.Println("Loading...")
		}
	}
}

func main() {
	fmt.Println("start TestTimeoutContext")
	ctx, cancel := context.WithTimeout(context.Background(), time.Second * 3)
	defer cancel()
	httpRequest(ctx)
	time.Sleep(time.Second * 5)
}

//start TestTimeoutContext
//Loading...
//Loading...
//Request timed out
```

**文件io或者网络io等耗时操作，可以查看剩余的时间是否充足，决定是否进行下一步操作**

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func copyFile(ctx context.Context)  {
	deadline, ok := ctx.Deadline()
	if ok == false {
		return
	}
	// deadline.Sub(time.Now()) 截止时间与当前时间的差值
	isEnough := deadline.Sub(time.Now()) > time.Second * 5
	if isEnough {
		fmt.Println("copy file")
	} else {
		fmt.Println("isEnough is false return")
		return
	}
}

func main() {
	ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Second * 4))
	defer cancel()
	copyFile(ctx)
	time.Sleep(time.Second * 5)
}


//isEnough is false return

复制代码
```



### 取消控制

**goroutine发送取消信号，保证自己这个逻辑中发散出去的goroutine全部成功取消**

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func gen(ctx context.Context) <-chan int {
	ch := make(chan int)
	go func() {
		var n int
		for {
			select {
			case ch <- n:
				n++
				time.Sleep(time.Second)
			case <-ctx.Done():
				return
			}
		}
	}()
	return ch
}

func main() {
	// 创建一个Cancel context
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	for n := range gen(ctx) {
		fmt.Println(n)
		if n == 5 {
			// 达到要求之后触发cancel
			cancel()
			break
		}
	}
}
//0
//1
//2
//3
//4
//5
```













基础相关：

1、golang 中 make 和 new 的区别？（基本必问）

2、数组和切片的区别 （基本必问）

3、for range 的时候它的地址会发生变化么？for 循环遍历 slice 有什么问题？

4、go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？（for defer）
defer recover 的问题？(主要是能不能捕获)

5、 uint 类型溢出

6、介绍 rune 类型

7、 golang 中解析 tag 是怎么实现的？反射原理是什么？(问的很少，但是代码中用的多)

8、调用函数传入结构体时，应该传值还是指针？ （Golang 都是值传递）

9、silce 遇到过哪些坑？

10、go struct 能不能比较？

11、Go 闭包

Context 相关：

1、context 结构是什么样的？

2、context 使用场景和用途？（基本必问）

Channel 相关：

1、channel 是否线程安全？锁用在什么地方？

2、go channel 的底层实现原理 （数据结构）

3、nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型）
例如：go channel close 后读的问题
向为 nil 的 channel 发送数据会怎么样？

4、向 channel 发送数据和从 channel 读数据的流程是什么样的？

Map 相关：

1、map 使用注意的点，并发安全？

2、map 循环是有序的还是无序的？

3、 map 中删除一个 key，它的内存会释放么？

4、怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？

5、 nil map 和空 map 有何不同？

6、map 的数据结构是什么？是怎么实现扩容？

7、map 取一个 key，然后修改这个值，原 map 数据的值会不会变化

GMP 相关：

1、什么是 GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的较少）

2、进程、线程、协程有什么区别？

3、抢占式调度是如何抢占的？

4、M 和 P 的数量问题？

5、协程怎么退出？

6、map 如何顺序读取？

锁相关：

1、除了 mutex 以外还有那些方式安全读写共享变量？

2、Go 如何实现原子操作？

3、Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？

4、Mutex 有几种模式？

5、goroutine 的自旋占用资源如何解决

6、读写锁底层是怎么实现的？

同步原语相关：

1、知道哪些 sync 同步原语？各有什么作用？
sync.pool 问的相对多些

2、sync.WaitGroup

并发相关：

1、怎么控制并发数？

2、多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？

3、如何优雅的实现一个 goroutine 池（百度、手写代码）

4、select 可以用于什么？

5、主协程如何等其余协程完再操作？

GC 相关：

1、go gc 是怎么实现的？（必问）

2、go 是 gc 算法是怎么实现的？ （得物，出现频率低）

3、GC 中 stw 时机，各个阶段是如何解决的？ （百度）

4、GC 的触发时机？

内存相关：

1、谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？

2、知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？

3、请简述 Go 是如何分配内存的？Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？

4、介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？

5、堆和栈的区别？

6、当 go 服务部署到线上了，发现有内存泄露，该怎么处理？

微服务框架

1、go-micro 微服务架构怎么实现水平部署的，代码怎么实现？

2、怎么做服务发现的

其他：

1、go 实现单例的方式？

2、项目中使用 go 遇到的坑？

3、client 如何实现长连接？

编程题：

1、3 个函数分别打印 cat、dog、fish，要求每个函数都要起一个 goroutine，按照 cat、dog、fish 顺序打印在屏幕上 100 次。

2、如何优雅的实现一个 goroutine 池？
